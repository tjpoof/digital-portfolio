{
  "geosynth": {
    "title": "GeoSynth",
    "type": "Music services",
    "stack": ["HTML", "CSS", "JavaScript", "TypeScript", "React", "Express", "Node.js", "Prisma", "MongoDB", "Spotify API", "Leaflet"],
    "shortDescription": "A web app that recommends new music to users based on location, mood, activity, and time of day.",
    "purpose": "The goal of this web application was to create a new way of recommending music to users based on information that they provide, such as location, mood, activity, and time of day. The main feature, which is creating playlists of these songs, is handled by allowing the user to input one of each tag and hosting the playlist on Spotify to listen to and/or save. \n\n Users are also able to rate how well each song fits the tags they provided by giving an optional upvote or downvote for each tag per song. Since the songs are tied to a playlist, these ratings can only be submitted once, meaning that if a user only rates one tag for one song in a playlist, they cannot go back to rate the playlist again after they submit. \n\n Users can also request songs to be added to the song database, labeling which tags the song(s) should fall under during the process. Song requests and their statuses can be viewed in the \"My Requests\" page, and admins are able to review these requests in the \"Moderation\" page, where they can approve requests to add songs to the database or mark them as denied.",
    "techStackExplanation": "The primary languages used in building GeoSynth included JavaScript and TypeScript, using React, HTML, and CSS in the frontend and Express/Node.js in the backend. MongoDB was used to manage the database of songs, playlists, user data, etc. and Prisma acted as our ORM to interact with the database. Several external plugins were used as well, such as Leaflet when building a dynamic map for users to navigate various locations.",
    "problemsThoughtProcess": "Most of the problems that were run into had to do with planning how the app would function, which was solved by creating various charts to visualize the flow of a user interaction, such as entity relationship and C4 diagrams. In the frontend, we solved most of our issues by making wireframes for the frontend to plan out how a user would navigate through the website. I was the primary contributor in making these wireframes, creating several drafts before settling on the final iteration that the site currently resembles.\n\n In the development process, I focused on the frontend, ensuring that users had a smooth experience navigating the website as well as working to integrate the backend to transfer data to and from the user, which included making API calls and ensuring that the user was authenticated through a login process. I was also behind most of the functionality regarding the frontend, with an example being the dynamic map where users are able to click on polygons drawn on a map powered by OpenStreetMap to choose a location. \n\n One problem I did run into during the development process was when showing a list of song results when a user searched for one in a search bar that connected to the Spotify API. If a song existed in our database already, it would both show that song and a copy of it from Spotify, showing potentially multiple results of the same song. On top of that, if a song was both a single and part of another album, then it would show multiple times. In order to fix these issues, I decided that if a song already exists in the database, I would mark it with a badge that showed it exists next to the title and I would only return one copy of each song in the results list.",
    "lessonsLearned": "Over the course of the development process, I gained a ton of experience when it comes to acting as a team lead; prior to this project, I had not taken the role entirely as I have really only worked in groups where each member is truly equal. In this project, each member had their own distinct responsibilities, such as acting as the testing or security lead. On top of that, I learned a lot more in planning out applications, as developing is not just the act of coding; I ended up giving more care in making sure what I create is as user-friendly as possible.",
    "githubLink": null,
    "liveDemo": null
  },
  "cyberattack-visualization-tool": {
    "title": "Cyberattack Visualization Tool",
    "type": "Data analysis services",
    "stack": ["HTML", "CSS", "JavaScript", "React", "JSON", "Chart.js", "D3", "Firebase"],
    "shortDescription": "A web app that helps users visualize cyberattack data through interactive graphs, heatmaps, and tables.",
    "purpose": "The goal of this project was to create an easy-to-use web app for users to visualize and analyze cyberattack data for educational and research purposes. \n\n Users are able to view various graphs, including a line chart to show total cyberattacks pear year, a bar chart to represent various industries affected, and a pie chart showing the distribution across industries. Users are able to select a date range as well as specific industries to filter out any unwanted data if they so desire. They are able to save these filters by generating a report and using the popout menu on the right side of the screen to load them later. \n\n Beyond the charts, there is also an interactive heatmap that shows various shades of blue to represent how often a country has been attacked, with deeper shades indicating more attacks. \n\n On top of this, users are able to view the raw data in a table format, where each attack listed includes the date, location, victim, industry affected, actor location, motive, type, sub-type, and actor data.",
    "techStackExplanation": "The primary language used in building this tool revolved around JavaScript, with React being used to manage the frontend. The app is entirely built as a frontend web application, so no backend integration was required beyond loading the cyberattack data from a JSON file. Beyond that, HTML and CSS were used as well, but that should be obvious considering it is a frontend web app.",
    "problemsThoughtProcess": "As this was my first true experience in building a full-on web application, there were bound to be issues that I would run into along the way. The primary issue was that finding an easy-to-use geographical map plugin was a lot more difficult than what was initially anticipated. As a team, we went through about two other plugins before settling on D3 for what the team wanted, which was creating a simple heatmap. Beyond that, there were difficulties reading the JSON data, but looking over documentation regarding how to import JSON objects and read from them fixed those issues rather quickly. \n\n I also took on the role of ensuring that the website looked as visually appealing as I could as a newer developer, so I had the responsibility of making sure that the website was consistent in its design on top of it being functional. I took inspiration from the website known as Speedtest by Ookla, as I was mainly fond of the color scheme. Building off of that, I was able to create a simple yet effective design for the cyberattack visualization tool.",
    "lessonsLearned": "Beyond just gaining experience building a website with a team, I primarily learned from this experience to really think about who I plan to work with, as one of my teammates relied on ChatGPT for most of their contributions, which did halt the development process a fair bit. Going forward, I made sure to work with people I knew I could trust to get work done while knowing what they are doing. For the record, I am not against using AI for developing, but it does get to a point where if you end up trying to connect a Python script to a JavaScript/React application then you do need to rethink what you are doing.",
    "githubLink": null,
    "liveDemo": "https://data-visualization-proje-aa39e.web.app/"
  },
  "parking-lot-manager": {
    "title": "Parking Lot Manager",
    "type": "Management services",
    "stack": ["Java", "SQL", "Swing"],
    "shortDescription": "A desktop application for managing parking permits and tracking parking violations for college campuses.",
    "purpose": "To streamline parking management for educational institutions by providing a comprehensive system for issuing permits, tracking violations, and analyzing parking patterns.",
    "techStackExplanation": "The primary languages used in the parking lot manager includes Java and SQL. The app runs entirely through Java and depends on the SQLite-JDBC jar file which has been included in the program. This file is necessary for database functionality. Some other dependencies are required for the pie chart, such as \"jfreechart\" and \"jcommon.\" Beyond these dependencies, Swing is what was used in building the GUI for the application.",
    "problemsThoughtProcess": "This project was the first time I have been put into a true group programming experience, so there were some initial issues regarding communication throughout the team. However, I brought up the idea of using a service such as Discord for team communications and it worked for the group flawlessly for the rest of the semester. \n\n Regarding the program itself, there were some struggles with figuring out how to communicate information from the database to the application and vice versa. Once these issues were realized, I took some responsibility in teaching some team members how SQL worked as well as referring them to some documentation regarding certain syntax, as I had taken courses that taught SQL prior. \n\n My main contributions in the app itself included the permit management section, which allowed users to add, remove, or renew permits to vehicles. I also helped in other areas when needed, but another key contribution I did make was building a UML diagram to better visualize how each class related to each other in the program, which did help the team in ensuring that no class was being forgotten.",
    "lessonsLearned": "As mentioned before, this project was the first time that I have ever really worked on a programming project in a group setting. Over the course of this project, I learned various lessons including how to effectively communicate with a team, knowing when to lend a hand when someone needs help or is struggling in some aspect, and figuring out how dividing up work effectively can lead to efficient programming if done properly.",
    "githubLink": null,
    "liveDemo": null
  }
}